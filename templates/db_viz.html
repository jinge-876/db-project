<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DB Visualization — bundled hierarchy</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
    svg { width: 100%; height: 100vh; display: block; }
    .node { font-size: 11px; cursor: pointer; }
    .node:hover { font-weight: bold; }
    .link { fill: none; stroke: steelblue; stroke-opacity: 0.4; stroke-width: 1.2px; }
    .link.highlight { stroke: orange; stroke-opacity: 0.9; stroke-width: 2.2px; }
    .node circle { fill: #fff; stroke: #000; stroke-opacity: 0.3; }
    .label { font-size: 11px; text-anchor: middle; pointer-events: none; }
    .tooltip {
      position: absolute;
      padding: 6px 8px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <svg id="viz"></svg>
  <div id="tooltip" class="tooltip"></div>

  <!-- D3 v7 (works fine with the code below) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // helper: fetch data and render
    fetch("/db_viz/data")
      .then(r => r.json())
      .then(d => render(d.classes || []) )
      .catch(err => {
        console.error("Failed to load /db_viz/data:", err);
        d3.select("body").append("p").text("Failed to load data. Check console.");
      });

    function render(classes) {
      // build a small hierarchy from dot-separated names
      function packageHierarchy(classes) {
        const map = new Map();

        function find(name, data) {
          let node = map.get(name);
          if (!node) {
            node = data || { name: name, children: [] };
            map.set(name, node);
            if (name.length) {
              const i = name.lastIndexOf(".");
              const parentName = i >= 0 ? name.substring(0, i) : "";
              const parent = find(parentName);
              parent.children.push(node);
            }
          }
          return node;
        }

        classes.forEach(d => find(d.name, d));
        return map.get("") ; // root
      }

      function packageImports(classes) {
        const map = new Map();
        const imports = [];
        // We'll map names to their node objects later, so just collect pairs
        classes.forEach(c => {
          const source = c.name;
          if (Array.isArray(c.imports)) {
            c.imports.forEach(t => {
              // ignore self or missing
              if (t && t !== source) imports.push([source, t]);
            });
          }
        });
        return imports;
      }

      const rootData = packageHierarchy(classes);
      // If there's no explicit root node created by names, create one
      if (!rootData) {
        // fallback: create trivial root
        rootData = { name: "", children: classes.map(c => ({ name: c.name, children: [] })) };
      }

      // --- D3 cluster setup ---
      const svg = d3.select("#viz");
      svg.selectAll("*").remove();
      const width = Math.max(800, window.innerWidth);
      const height = Math.max(800, window.innerHeight);
      svg.attr("viewBox", [-width/2, -height/2, width, height]);

      const radius = Math.min(width, height) / 2 - 100;

      // create d3.hierarchy and cluster layout
      const root = d3.hierarchy(rootData, d => d.children);
      const cluster = d3.cluster().size([360, radius]);
      cluster(root);

      // Map name -> leaf node (hierarchy node with x,y)
      const nameToNode = new Map();
      root.leaves().forEach(leaf => {
        // leaf.data may contain label and original name
        const name = leaf.data.name;
        nameToNode.set(name, leaf);
        // save display label if present
        leaf.displayLabel = (leaf.data.label !== undefined) ? leaf.data.label : name;
      });

      const imports = packageImports(classes)
        .map(pair => {
          const s = nameToNode.get(pair[0]);
          const t = nameToNode.get(pair[1]);
          if (s && t) return {source: s, target: t};
          return null;
        })
        .filter(x => x);

      // line generator: radial
      const line = d3.lineRadial()
        .curve(d3.curveBundle.beta(0.85))
        .radius(d => d.y)
        .angle(d => (d.x / 180) * Math.PI);

      // helper to compute path between two nodes via ancestors
      function pathBetween(a, b) {
        const aAnc = a.ancestors(); // from a -> root
        const bAnc = b.ancestors(); // from b -> root

        // find common ancestor index from the end
        let i = aAnc.length - 1;
        let j = bAnc.length - 1;
        while (i >= 0 && j >= 0 && aAnc[i] === bAnc[j]) { i--; j--; }
        // i and j now point to last non-common entries
        const path = aAnc.slice(0, i + 1).reverse().concat(bAnc.slice(0, j + 1));
        return line(path);
      }

      // Draw links (edges)
      const linkG = svg.append("g").attr("class", "links");
      const link = linkG.selectAll("path")
        .data(imports)
        .join("path")
        .attr("class", "link")
        .attr("d", d => pathBetween(d.source, d.target));

      // Draw leaf nodes arranged on outer circle
      const nodeG = svg.append("g").attr("class", "nodes");
      const nodes = nodeG.selectAll("g.node")
        .data(root.leaves())
        .join("g")
        .attr("class", "node")
        .attr("transform", d => `
          rotate(${d.x - 90})
          translate(${d.y},0)
        `)
        .on("mouseover", function(event, d) {
          // highlight related links
          const name = d.data.name;
          link.classed("highlight", l => (l.source === d || l.target === d));
          // show tooltip
          const tt = d3.select("#tooltip");
          tt.style("display", "block")
            .html(`<strong>${d.displayLabel}</strong><br/><em>${d.data.name}</em>`);
        })
        .on("mousemove", function(event) {
          const tt = d3.select("#tooltip");
          tt.style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY + 10) + "px");
        })
        .on("mouseout", function() {
          link.classed("highlight", false);
          d3.select("#tooltip").style("display", "none");
        })
        .on("click", function(event, d) {
          // toggle highlight on clicked node
          const currently = d3.select(this).classed("active");
          d3.selectAll("g.node").classed("active", false);
          d3.selectAll("path.link").classed("highlight", false);
          if (!currently) {
            d3.select(this).classed("active", true);
            link.classed("highlight", l => (l.source === d || l.target === d));
          }
        });

      nodes.append("circle")
        .attr("r", 3);

      // labels: draw outside the circle and rotate back to horizontal
      nodes.append("text")
        .attr("dy", "0.31em")
        .attr("x", d => d.x < 180 ? 6 : -6)
        .attr("text-anchor", d => d.x < 180 ? "start" : "end")
        .attr("transform", d => d.x >= 180 ? "rotate(180)" : null)
        .text(d => d.displayLabel);

      // legend (simple)
      svg.append("text")
        .attr("x", -width/2 + 20)
        .attr("y", -height/2 + 30)
        .attr("font-size", 12)
        .text("Bundled hierarchy: users & todos — hover nodes to highlight connections");
    }

    // make it responsive on resize
    window.addEventListener("resize", () => {
      // re-fetch and render (cheap for small DBs)
      fetch("/db_viz/data").then(r => r.json()).then(d => render(d.classes || []));
    });
  </script>
</body>
</html>
